.TH "rcppsw" 3 "Sat Feb 5 2022" "RCPPSW" \" -*- nroff -*-
.ad l
.nh
.SH NAME
rcppsw \- The root namespace of the RCPPSW library\&.  

.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBal\fP"
.br
.ti -1c
.RI " \fBalgorithm\fP"
.br
.RI "Various algorithms: closest pair, max subarray, clustering\&. "
.ti -1c
.RI " \fBconfig\fP"
.br
.RI "Base namespace for run-time configuration parsing and data containers\&. Currently includes base class implementations for: "
.ti -1c
.RI " \fBcontrol\fP"
.br
.RI "Control theory classes: periodic/aperiodic waveform generators, PID loops, etc\&. and their configuration\&. "
.ti -1c
.RI " \fBdetail\fP"
.br
.ti -1c
.RI " \fBds\fP"
.br
.RI "Data structures: 2D/3D lattice grids, 2D/3D discretizing grids to overlay onto continuous space, Poisson queue, rtree for 2D space, heterogeneous stacked 2D grid, type map for using in C++ quasi-reflection\&. "
.ti -1c
.RI " \fBer\fP"
.br
.RI "The Event Reporting framework used in RCPPSW and its derived projects\&. "
.ti -1c
.RI " \fBmath\fP"
.br
.RI "Pure mathematical classes such as vectors, ranges, sigmoids, etc\&. "
.ti -1c
.RI " \fBmetrics\fP"
.br
.RI "Base metric interfaces and the collectors for them\&. "
.ti -1c
.RI " \fBmpl\fP"
.br
.RI "Meta programming namespace\&. Mainly a few aliases around things which boost provides\&. "
.ti -1c
.RI " \fBmultiprocess\fP"
.br
.RI "Multi-process variants of other classes: queue\&. Forkable interface\&. "
.ti -1c
.RI " \fBmultithread\fP"
.br
.RI "Multi-threaded variants of other classes: FSM, queue, vector, threadable interface for daemon-esque classes, lockable interface\&. "
.ti -1c
.RI " \fBpatterns\fP"
.br
.RI "Design pattern templates and interfaces\&. "
.ti -1c
.RI " \fBtypes\fP"
.br
.RI "Common non-primitive types: Spatial distance/range, timestep, UUID for types, named type (for eliminating bugs caused by implicit conversions between primitive types which do not elicit a compiler warning)\&. "
.ti -1c
.RI " \fButils\fP"
.br
.RI "Various utility things which don't fit anywhere else: Base CLI parsing class, file/line parsers, colors, enum utilities, string utilities\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename TEnum > constexpr std::underlying_type< TEnum >::type \fBas_underlying\fP (const TEnum &e) noexcept"
.br
.RI "Get the value of a strongly typed enum as its underlying type\&. "
.ti -1c
.RI "template<typename T , typename std::enable_if<(!mpl::is_detected< detail::to_str_type, T >::value), int >::type  = 0> std::string \fBto_string\fP (const T &obj)"
.br
.RI "For \fCT\fP where std::to_string(\fCT\fP) works let the stdandard library to the conversion\&. "
.in -1c
.SH "Detailed Description"
.PP 
The root namespace of the RCPPSW library\&. 

It is better to define the namespace aliases exported by RCPPSW here, rather than having them be multiply defined in different downstream projects (DRY FTW!)\&.
.PP
Convention: Namespace aliases from RCPPSW all start with \fC'r'\fP, and the first letter of all nested namespaces except the innermost one should be included before the innermost\&. For example, \fBrcppsw::patterns::visitor\fP should have the \fC'r'\fP from \fC'rcppsw'\fP and the \fC'p'\fP from \fC'patterns'\fP before the target namespace \fC'visitor'\fP\&. 
.SH "Function Documentation"
.PP 
.SS "template<typename TEnum > constexpr std::underlying_type<TEnum>::type rcppsw::as_underlying (const TEnum & e)\fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Get the value of a strongly typed enum as its underlying type\&. 
.SS "template<typename T , typename std::enable_if<(!mpl::is_detected< detail::to_str_type, T >::value), int >::type  = 0> std::string rcppsw::to_string (const T & obj)"

.PP
For \fCT\fP where std::to_string(\fCT\fP) works let the stdandard library to the conversion\&. For \fCT\fP where std::to_string(\fCT\fP) does not work, if \fCT\fP defines a to_str() method, then it can still use \fBrcppsw::to_string()\fP\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for RCPPSW from the source code\&.
